---
date: "2019-07-03"
author: arakawa
tags: [OLTP, compiler]
---

# SQLにおける副問合せの展開方法

2019-07-03 arakawa (NT)

## この文書について

問合せに含まれる副問合せを展開し、処理（または処理系の実装が）が容易な演算木に変換する方法について検討および検証する。

## 表記について

### 演算式

リレーション式
~ `U`, `V`, `W`, ... またはそれらに1つ以上の `'` (プライム) を付与したもの

スカラー式
~ `a`, `b`, `c`, ...

述語
~ `P`, `P1`, `P2`, ...

関係演算子
~ `R(...)`

  * 複数の演算種が出現する場合、 `R1`, `R2`, ...
  * `(...)` は被演算子
    * 1個以上のリレーションをとり、0個の場合には `()` を省略

関係演算子詳細
~ `r{...}(...)`

  * `r` は演算種
    * 複数の演算種が出現する場合、 `r1`, `r2`, ...
  * `{...}` は演算パラメータ
    * 複数の演算子パラメータをとる演算子種の場合、 `r{...}{...}` のように `{...}` を複数個書く
    * `r{...}` の部分が前述の `R` に相当
  * `(...)` は被演算子
    * 1個以上のリレーションをとり、0個の場合には `()` を省略

演算パラメータ
~ `p`, `p1`, `p2`, ...

  関係演算子詳細に出現する `r{p1}{p2}(...)` のためのラベル。

テーブル名
~ `T`, `T1`, `T2`, ...

参照名
~ `U as V`

  * `U` は任意のリレーションを表す式
  * `V` は参照名

カラム
~ `x`, `y`, `z`

  または `U.x` のように `<リレーション>.<カラム名>`

  2つのリレーション `U`, `V` を結合してリレーション `W` を構築した場合、結合前のカラム `U.x`, `V.y` はそれぞれ `W.U.x`, `W.V.y` で参照可能であるものとする。
  また、あいまいさがない場合には `U.x`, `V.y`, `W.x` などリレーション名を省略してもよい。
  本文書において「リレーション名」は厳密なものではなく、対象のカラムを文脈から一意に特定するためのヒントとしてのみ記述するものとする。

### 関係演算子

スキャン
~ `scan{T}`

  対象のテーブルの内容をリレーションとして扱う。

  * `T` はスキャン対象のテーブル名

射影
~ `project{column, ...}(U)`

  リレーション `U` の各行を `column, ...` からなる行に変換したリレーションを構成する。

  * `column` は以下の形式:
    * `*` - 対象のリレーションのすべてのカラムを結果に追加する
    * `U.*` - リレーション `U` 由来のすべてのカラムを結果に追加する
    * `x = a` - カラム `x` の内容を `a` の評価結果に **置き換える**
    * `-x` - カラム `x` を結果から **取り除く**
    * `+x = a` - カラム `x` を結果に **追加** し、その値を `a` の評価結果とする
      * 左辺を省略する場合がある (カラム名が重要でない場合)
  * `U` は任意のリレーションを表す式

選択
~ `filter{expr}(U)`

  リレーション `U` の各行のうち、述語 `expr` を満たさない行を取り除いたリレーションを構成する。

  * `expr` は任意の論理式
  * `U` は任意のリレーションを表す式

結合
~ `join{kind}{expr}(U, V)`

  リレーション `U`, `V` を指定した方式で結合した新しいリレーションを構成する。

  * `kind` は以下のいずれか:
    * `cross`
    * `inner`
    * `{left,right,full}-outer`
    * `{left,right}-semi`
      * `join{left-semi}{U.x=V.x}(U, V)` のような演算を考えた際に、`u in U` に対して `v in V, u.x = v.x` となるような `v` が存在するような `u` からなるリレーションである `({u in U: exists v in V, if u.x = v.x})`
        * つまり、上記の `u` に対して `v` が2つ以上存在しても、 `u` は結果のリレーションに一度しか出現しない
      * `right-semi` の場合も同様
    * `{left,right}-anti`
      * `theta` は任意の論理式
    * ただし、 `kind=cross` の場合や、説明上で重要でない場合は省略
  * `expr` は任意の論理式
  * `U`, `V` はそれぞれ任意のリレーションを表す式

和集合
~ `union{kind}(U, V)`

  リレーション `U`, `V` を指定した方式で和をとった新しいリレーションを構成する。

  * `kind` は以下のいずれか
    * `set` - 被演算子を集合として扱い、行IDを除いた重複行を排除したのち、行IDを振りなおす
    * `all` - 被演算子をいずれも多重集合として扱い、連接をとった後に行IDを振りなおす
    * `id` - 和をとる際に、同一の行IDを持つ行を排除する
      * すべての被演算子が同じリレーションを祖先に持つ場合（かつ、いずれも行IDを再生成されていない場合）のみ指定可能

集約
~ `aggregate{key, ...}{expr, ...}(U)`

  リレーション `U` を指定した方式で集約し、その結果からなるリレーションを構成する。

  * `key` は0個以上の任意の式で、グループ化キーを指定 (0ならリレーション全体)
  * `expr` は `x = a` の形式で、集約式 (`a`) と集約結果のカラム名 (`x`)
    * 左辺を省略する場合がある (カラム名が重要でない場合)
  * `U` は任意のリレーションを表す式

重複除去
~ `distinct{key, ...}(U)`

  リレーション `U` から、指定した等価性における重複行を取り除いたリレーションを構成する。

  * `key` は1個以上で、以下の形式
    * `*` - 行IDを除くすべてのカラム列の等価性を用いて重複を除去
    * `-x` - 等価性を判定する際に、 カラム `x` を考慮しない
    * `(expr)` - 等価性の条件に式 `expr` を追加
  * `U` は任意のリレーションを表す式

行数制限
~ `limit{N}{key, ...}{order, ...}(U)`

  リレーション `U` から、指定した等価性によって直和集合を構成し、各集合における最大行数を制限する。

  * `N` は1以上
  * `key` は0個以上の式で、等価性のキーを表す
    * 未指定の場合、リレーション全体を `N` 行に制限する
  * `order` は0個以上の式で、制限する行の優先順位を指定する
    * 未指定の場合、任意の行を除去する
    * 1個以上の要素が指定された場合、それらの要素をもとに直和集合の各集合の要素を整列し、個々の集合に含まれる上位 `N` 行以外を除去する
  * `U` は任意のリレーションを表す式

整列
~ `sort{key, ...}(U)`

  リレーション `U` に含まれる業を、指定した方法で整列したリレーションを構成する。

  この演算は計算モデル上意味がない（リレーション内の行の順序を考慮しない）が、備忘のため残しておく。

  * `key` は0個以上の任意の式で、整列順序を表す
  * `U` は任意のリレーションを表す式

### スカラー演算子

スカラー化
~ `scalar(U)`

  1行1列のリレーション `U` をスカラー値として取り扱う疑似演算子。

  * `U` は任意のリレーションを表す式
    * ただし、 `U` は1列でなければならず、かつ **高々** 1行でなければならない

量化
~ `exists(U)`

  リレーション `U` に1行以上含まれているかどうかを判定する疑似演算子

  * `U` は任意のリレーションを表す式

標準的なスカラー演算子
~ 以下の演算子を利用する)

  * 四則演算
    * `+`, `-`, `*`, `/`
  * 論理演算
    * `NOT`, `AND`, `OR`
  * 比較演算
    * `=`, `<>`, `<`, `>`, `<=`, `>=`

### 演算木

演算式が複雑な場合、演算木 (expression tree) として図示する場合がある。

演算式を `r{p1}{p2}... (U, V, ...)` の形式とした場合、対応する演算木は以下のように描く。

```txt
U  V
|  |
 \/
 r
{p1}
{p2}
```

上記のうち `r` を「演算種」, `p1`, `p2` をそれぞれ「演算パラメータ」, `U`, `V` を「被演算子」とよぶ。

データベースの分野における expression tree の表記と **異なり** 、被演算子を図の上部に置くことに注意されたい。

### 例

```txt
SELECT U.x FROM T1 U
-> project{U.x}(scan{T1} as U)

scan{T1} as U
      |
 project {U.x}
```

```txt
SELECT * FROM T1 U WHERE y = 1
-> filter{U.y = 1}(scan{T1} as U)

scan{T1} as U
      |
 filter{U.y=1}
```

```txt
SELECT * FROM T1 U JOIN T2 V ON U.x = V.x
-> join{inner}{U.x=V.x}(scan{T1} as U, scan{T2} as V)

scan{T1}  scan{T2}
  as U      as V
    |         |
join{inner}{U.x=V.x}
```

```txt
SELECT MAX(U.x) - MAX(U.y) FROM T1 as U GROUP BY U.c
-> aggregate{U.c}{max(U.x) - max(U.y)}(scan{T1} as U)

   scan{T1} as U
         |
   aggregate{U.c}
{max(U.x) - max(U.y)}
```

## 計算モデルについて

### 行の一意性

すべてのリレーションには、 `id` という名前の「行ID」を表す疑似カラム (行ID) が存在する。
この値は常にリレーション内で一意であり、これによってリレーション内の行データは常にリレーション内で一意である。
演算によってこの一意性が崩れる場合、その演算は暗黙に **行IDを再生成** する。

各リレーション演算子によって行IDを明示的に変更することは不可能であり、演算の結果によって一意性が失われる際に、リレーション全体に対して新たに附番しなおす（つまり、tuple by tuple の演算の前後において行IDは常に維持される）。
また、2つのリレーション `U`, `V` を結合してリレーション `W` を構築した場合、 `W.U.id`, `W.V.id` はそれぞれ結合前のリレーションで規定された行IDを指し、結合結果の `W.id` は結合後のリレーションにおける行IDを指す。

行ID同士を比較する場合、それらの行IDが **同一の箇所で附番されている場合のみ** おこなえる（リレーション全体に附番する際に、行IDのカラムを **新しい型で** 追加しているに近しい）。
たとえば、2つのリレーション `U`, `V` を結合してリレーション `W` を構築した場合、結合前の `U.id` と、結合後の `W.U.id` はそれぞれ比較可能であるが、 `U.id`, `V.id`, `W.id` はいずれも互いに比較不可能である。

### 行の順序

本文書における計算モデルでは、リレーション内の行の順序を考慮しない。

このため、本文書に記載された副問合せの展開方法は、リレーション内の行の順序を考慮する計算モデル（例えば、sort merge joinを明示的に行うような物理実行計画）においては適用できない。

ただし、 `limit{N}{key, ...}{order, ...}()` における `{order, ...}` は例外的に順序を取り扱う。ただしこれは、リレーション内の順序というよりは、演算の内部で制限する行を選択するための条件に等しい。

## 演算木の「正規形」

ある演算木 `T` が *正規形 (normal form)* である場合、 `T` に出現するそれぞれの *関係演算子 (relational operator)* `R` は以下のような性質をすべて満たす

* `R` の評価結果はリレーションである (整形式性:データ)
* `R` の被演算子は、各演算子の種類に定められた個数を厳格にとる (整形式性:演算子)
  * `scan` 演算子は被演算子をとらない (0個の被演算子をとる)
  * `join`, `union` 演算子はちょうど2つの被演算子をとる
  * 上記を除くすべての関係演算子は、ちょうど1つの被演算子をとる
    * 集合の差、積、商など実際にはほかにも多項演算があるが、面倒なのでとりあえず無視する
* `R` の *演算パラメータ* (例えば、 `filter` 演算子における述語) には関係演算子が出現しない (平坦性)
* `R` の *演算パラメータ* 中に出現するすべてのカラムの参照は、被演算子に出現するカラムを指している必要がある (参照可視性)

演算木 `T` に対し、その正規形 `T'` を得る変換のことを、「正規化」とよぶ。なお、 `T` に対して `T'` は必ずしも一意でなく、同様に正規化の手法も複数存在しうる。

### 正規形でない例

* 演算パラメータに関係演算子が出現する (`filter{exists(scan...)}`)

  ```txt
       scan{T1}
          |
        filter
  {exists(scan{T2})}
  ```

* 被演算子に存在しないカラムを参照している (`filter{V.x=U.x}`)

  ```txt
             scan{T2}
               as V
                |
  scan{T1}    filter
    as U    {V.x=U.x}
      \         /
       \       /
      join{cross}
  ```

### 正規形であることの利点

演算木が正規形であることにより、実際の演算を行う上で以下のような利点が得られる。

* 整形式性:データ
  * 演算の結果が常にリレーションであることにより、演算子間のデータの交換が容易になる
* 整形式性:演算子
  * 演算子の入出力形式が演算子ごとに定められていることにより、演算子の実装が容易になる
* 平坦性
  * 演算木が本質的に平坦な非循環有向グラフ (DAG) で表現できることで、演算のスケジューリングや処理の並列化、必要リソースの見積もり等が行いやすい
* 参照可視性
  * 平坦性と合わせて各演算が局所的なデータしか触らないことで演算子内の処理の局所性が増すため、演算子やスケジューラの実装が単純化し、かつ並列化が容易になる

ただし、上記の恩恵を受けるためには、正規形で表現不可能な処理が含まれていてはならない。

### 正規化の方針

本プロジェクトでは、以下の方針で正規化を行うものとする。

1. 単純な規則の組み合わせによって正規化を行う
2. 正規化の結果出現しうる演算木の部分木の構造をもとに、有効な最適化を適用する
3. 「正規化」-「最適化」の組の短絡化が可能なイディオムを発見し、必要に応じて1の手順の代わりにイディオムをもとに変換する

このため、2の最適化が不十分であったり、または3のイディオムが不十分である場合に、実行時の性能が効率的でない演算木が生成される場合がある。

### その他の項目

* 正規化の方式は木構造をもとに検討する
  * 現在は実行形式はDAGをもとにしたものを考えているが、正規化の理論はtreeをもとに考えるものとする
    * あらゆる演算子が参照透過性を有する場合に、expression DAG を expression tree に変換しても等価な結果を得られるが、参照透過性は必ずしも保証されていないため本来は正しくない変換
    * -> この部分は別のレイヤで保証するので、とりあえずは参照透過性があるものとして読み進めていただきたく (TBD: というより、SQLは構造的に考慮しなくても大丈夫そう？)
  * 図示する場合には、DAGのまま表示する場合がある (見やすさのため)

## 副問合せの種類

副問合せは主に以下の3種類の出現箇所がある。

1. `FROM`, `JOIN` 句
2. 量化副問合せ (`EXISTS`, `IN`, `SOME`, `ALL`)
3. スカラー副問合せ

また副問合せが、その副問合せを（再帰的に）含む問合せ（主問合せ）に出現する列を参照する場合、そのような副問合せを「相関副問合せ」とよぶ。
逆に、主問合せに出現する列を参照しない場合、そのような副問合せを「非相関副問合せ」とよぶ。

相関副問合せは参照可視性に違反するため、それが含まれる問い合わせは正規形とならない。

## 平坦性の担保

本セクションでは、副問合せの種類ごとに、それらを「平坦」な演算木に変換する方法（平坦化）を検討する。

なお、相関副問合せによる参照可視性に違反する構造について、本セクションでの変換結果をもとに対処するものとする。

### `FROM`, `JOIN` 句

`FROM`, `JOIN` 句に副問合せを指定した場合、平坦性には違反しない。

### 量化副問合せ

#### `EXISTS` 句

`EXISTS` 句のみからなる `WHERE` 句 (`filter{exists(V)}(U)`) は次の形式に変換できる。

```txt
filter{exists(V)}(U)
-> join{left-semi}{U.id = W.U.id}(U, join{cross}(U, V) as W)

 U
 +       V
/ \      |
| join{cross} as W
|        |
join{left-semi}
 {U.id=W.U.id}
```

#### 述語の分解

`WHERE` 句に `EXISTS` 句以外の項が含まれる場合、以下のように変換できる。

* `P1 AND P2` の場合

  ```txt
  filter{P1 AND P2}(U)
  ->
  filter{P1}(filter{P2}(U))
  ```

* `P1 OR P2` の場合

  ```txt
  filter{P1 OR P2}(U)
  ->
  union{id}(filter{P1}(U), filter{P2}(U))

       U
       +
      / \
 filter  filter
   {P1}  {P2}
      \  /
   union{id}
  ```

  * TBD: `NOT (...)`
  * TBD: 実行時に効率が悪そうなので、もう少し考えてもよさそう
    * -> 先に CNF に変換すべき？

#### `NOT EXISTS` 句

`NOT EXISTS` 句 (`filter{NOT exists(V)}(U)`) は、 `EXISTS` 句における `semi-join` を `anti-join` に置き換えたものに等しい。

```txt
filter{NOT exists(V)}(U)
-> join{left-anti}{U.id = W.U.id}(U, join{cross}(U, V) as W)

 U
 +       V
/ \      |
| join{cross} as W
|        |
join{left-anti}
 {U.id=W.U.id}
```

#### `IN`, `NOT IN` 句

`IN`, `NOT IN` 句はそれぞれ `EXISTS`, `NOT EXISTS` 句に置き換えられる。ただし、必ず相関副問合せとなる。

```sql
SELECT * FROM U
WHERE U.x IN (
  SELECT V.x FROM V
  WHERE P
)
-- ->
SELECT * FROM U
WHERE EXISTS (
  SELECT * FROM V
  WHERE P AND U.x = V.x
)
```

#### `SOME`, `ALL` 演算子

`SOME`, `ALL` によって修飾された演算子は、それぞれ `EXISTS`, `NOT EXISTS` 句に置き換えられる。ただし、必ず相関副問合せとなる。

```sql
SELECT * FROM U
WHERE U.x <SOME (
  SELECT V.x FROM V
  WHERE P
)
-- ->
SELECT * FROM U
WHERE EXISTS (
  SELECT * FROM V
  WHERE P AND U.x < V.x
)
```

```sql
SELECT * FROM U
WHERE U.x <ALL (
  SELECT V.x FROM V
  WHERE P
)
-- ->
SELECT * FROM U
WHERE NOT EXISTS (
  SELECT * FROM V
  WHERE P AND U.x < V.x IS FALSE
)
```

### スカラー副問合せ

スカラー副問合せは、問合せ中のあらゆるスカラー値を指定可能な箇所に出現し、また相関副問合せも利用可能である。

スカラー問合せを含む演算子 `r{.. scalar(V) ..}(U)` は次のように変換できる。

```txt
r{.. scalar(V) ..}(U)
-> project{*,-v}(r{.. v ..}(project{*, +v=scalar(V)}(U)))

       U
       |
     project
{*, +x=scalar(V)}
       |
  r{.. x ..}
       |
 project{*, -x}
```

さらに、上記のうち `project(*, scalar(V)}(U)` は次のように変換できる。

```txt
project{*, scalar(V)}(U)
-> join{left-outer}{U.id = W.U.id}(U, join{cross}(U, V) as W)

   U
   +       V
  / \      |
  | join{cross} as W
  |        |
join{left-outer}
 {U.id=W.U.id}
```

上記は結果として余計なカラムが付与されることになるが、それを是正するための射影は省略している。

なお、上記はスカラー副問合せの結果が2行以上になる場合に期待した動作とならない。
TBD: この検査を現実的に行うには、 `join{left-outer}` の特殊なケースを用意し、左の各行に対し、対応する右の行が高々1行であることを検査すればよさそう。

## 参照可視性の担保

本セクションでは、前項「平坦性の担保」によって得られた（平坦な）演算木に対し、参照可視性に違反する演算子を是正（参照可視化）することで正規形である演算木を得る。

### 相関副問合せであるかどうかの判断

相関副問合せとは、主問合せの列を参照しているような副問合せのことである。

ここでは、より厳密に次のように定義する。

* ある主問合せ `U` と、 `U` に直接含まれる副問合せ `V`, および `U` のうち `V` を含まない全体の部分木 `U'` について
  * `V` または `V` に再帰的に含まれる副問合せ上の演算子が `U'` 上の列を参照している場合、 `V` は相関副問合せである
  * そうでない場合、 `V` は非相関副問合せである

例を挙げると、ある主問合せ `U`, `U` に直接含まれる副問合せ `V`, および `V` に直接含まれる副問合せ `W` があり、 `U'` を `U` のうち `V` を含まない全体の部分木とする。
このとき、 `W` が `U'` 上の列を参照している場合、 `V` は相関副問合せであるが、 `W` は非相関副問合せとなる。
ただし、 `W` が `V` のうち `W` を含まない部分木上の列を参照している場合に限り、 `W` も相関副問合せとなる。

つまり、相関副問合せとなるのは、副問合せ（それ自身が含む副問合せも再帰的に含む）が、直接の主問合せの列を参照している場合のみである。

### 共通の構造

ある演算子 `r{.. V ..}(.. U ..)` に副問合せ（ `V` ）が含まれていた場合、平坦化では以下のような共通の部分木を生成していた。

```txt
  U    V
  +    |
 / \   |
|   \ /
 \   X
  \  |
 join{kind}
{U.id=W.U.id}
     |
    ...
```

なお、 `U X V` は `join{cross}(U, V)` の略記である。また、図下部の `join{kind}` は副問合せの種類によって異なる。

このとき、 `V` が相関副問合せであり、 `V = R1(R2(..Rk(V')..))` のような形式で表せ、 `V'` （を構成する部分木）は参照可視性に違反しないものとする。
このような場合、 `V` を含む部分木 `U X V` (`V = R1(R2(..Rk(V')..))`) を次のように変形することで、参照可視化できる。

```txt
U X R1(R2(.. Rk(V') ..))

    V'
    |
    Rk
    |
    .
    .
    |
U   R1
 \ /
  X

-> R1'(R2'(.. Rk'(U X V') ..))


U   V'
 \ /
  X
  |
 Rk'
  |
  .
  .
  |
 R1'
```

ただし、 `Ri' = R1', R2', .., Rk'` は任意のリレーション `U` と、 `Ri` が被演算子にとりうる任意のリレーション `V` に対し、それぞれ以下を満たす。

```txt
U X Ri(V) = Ri`(U X V)
```

なお、 `U X R(V) = R(U X V)` となるような `R` は「直積において交換可能である」とよぶ。

まとめると、相関副問合せを以下のような構造に変形することで、正規形を得ることができる。

```txt
  U
  +   V'
 / \ /
|   X
|   |
|  Rk'
|   |
|   .
|   .
|   |
|  R1'
|  as W
 \  |
 join{kind}
{U.id=W.U.id}
     |
    ...
```

以降では、演算子の種類ごとに式変形の方法を検討する。

### `FROM`, `JOIN` 句の取り扱い

`FROM`, `JOIN` 句で副問合せが指定された場合、その副問合せ内では直接の主問合せの列を参照することはできない。
つまり、同副問合せは、本文書における「相関副問合せ」には該当しない。

### 直積において交換可能な演算子

以下の演算子は直積において交換可能である。

* `filter` (選択)
* `join` (結合)
* `union` (和集合)

### スキャン

`scan` はカラムの参照を行わず、かつ被演算子が存在しないため、そもそも参照可視性に違反しえない。

### 射影

`project` は次の式が成り立つ。

```txt
U X project{p}(V) = project{p, U.*}(U X V)
```

### 集約

`aggregate` は次の式が成り立つ。

```txt
U X aggregate{p1}{p2}(V)
= join{inner}{U.id}(aggregate{p1, U.id}{p2, U.id}(project{U.id, V.*}(U X V)))

  U    V
  +    |
 / \   |
/   \ /
|    X
|    |
|   project
| {U.id, V.*}
|      |
|  aggregate
|  {p1, U.id}
|  {p2, U.id}
 \     |
  \    |
join{inner}{U.id}
```

### 重複除去

`distinct` は次の式が成り立つ。

```txt
U X distinct{p}(V) = distinct{p, U.id}(U X V)
```

### 行数制限

`limit` は次の式が成り立つ。

```txt
U X limit{N}{p1}{p2}(V) = limit{N}{p1, U.id}{p2}(U X V)
```

### 整列

副問合せ中に出現する `sort` は、本モデルにおいて計算結果に影響を与えない (*1)。

## 最適化について

### スカラー副問合せの短絡化

以下の副問合せの変形において、

```txt
project{*, scalar(V)}(U)
-> join{left-outer}{U.id = W.U.id}(U, join{cross}(U, V) as W)

   U
   +       V
  / \      |
  | join{cross} as W  #1
  |        |
join{left-outer}      #2
 {U.id=W.U.id}
```

図中の `#2` の結果は `U` の列が二重に含まれているため、正確には以下のようなコードとなる。

```txt
   U
   +       V
  / \      |
  | join{cross} as W  #1
  |        |
  |      project
  |    {U.id, V.*}    #3
  |        |
join{left-outer}      #2
 {U.id=W.U.id}
```

ここで、 `V` が非相関副問合せであり、かつ高々1行であるとすると、これは以下と等価である。

```txt
project{*, scalar(V)}(U)
-> join{left-outer}{U.id=W.U.id}(U, V)

    U     V
    |     |
join{left-outer}
```

なお、 projection push down をやりやすくするため、上図の `#3` は常に考慮すべきである。

非相関副問合せの場合（正規化後）も同様に、

```txt
   U
   +       V'
  / \      |
  | join{cross}
  |        |
  |        R
  |        |
  |      project
  |    {U.id, V.*}
  |        |
join{left-outer}
 {U.id=W.U.id}
```

を

```txt
   U
   +       V'
  / \      |
  | join{cross}
  |        |
  |      project
  |    {U.id, V.*}
  |        |
join{left-outer}
 {U.id=W.U.id}
       |
       R'
```

のように変形することで、

```txt
    U     V'
    |     |
join{left-outer}
       |
       R'
```

を得られる可能性がある。

### 量化副問合せの短絡化

以下の副問合せの変形において、

```txt
filter{exists(V)}(U)
-> join{left-semi}{U.id = W.U.id}(U, join{cross}(U, V) as W)

 U
 +       V
/ \      |
| join{cross} as W
|        |
join{left-semi}
 {U.id=W.U.id}
```

`V` が非相関副問合せである場合、これは以下と等価である。

```txt
filter{exists(V)}(U)
-> join{left-semi}(U, V)

    U     V
    |     |
join{left-semi}
```

スカラー副問合せの例と同様に、非相関副問合せであっても、式の変形で同様の短絡化をおこなえる可能性がある。

### 参照可視化における重複除去と行数制限の短絡化

参照可視化の過程で、重複除去 (`distinct`) と行数制限 (`limit`) は比較的高コストな演算に置き換えられてしまう可能性がある。

たとえば、 `U X limit{N}(V) = limit{N}{U.id}(U X V)` となり、左辺の `limit` は「全体から `N` 行だけ取り出す」という演算であるが、右辺の `limit` は「全体を `U.id` の同値類に分割し、それぞれの集合を `N` 要素に制限する」という複雑な処理になる。

しかしながら、副問合せ中にこれらの演算が出現する場合、ほとんどのケースでは副問合せの末尾 (downstream) に出現することが予想される。
つまり、最終的に以下のような形式になる蓋然性がある。

```txt
      U
      +       V'
     / \      |
     | join{cross} as W
     |        |
     |        R
     |        |
     |  limit/distinct
     |        |
join{left-{semi,outer}}
     {U.id=W.U.id}
```

まず、左半結合 (left semi-join) の右項の最外の演算が `limit` または `distinct` である場合、これらの `limit` や `distinct` は省略可能である (TBD)。

同様に、左外結合 (left outer join) の場合について考える。

参照可視化の性質により、これらの `limit` や `distinct` は `U.id` をキーに含む同値類についてそれぞれ行数削減を行っている。そのため、被演算子で特定の `U.id` を持つ行が存在していた場合、またはその場合に限り、演算結果にもその `U.id` を持つ。

ここで、左外結合の実装について考えてみると、上記の `join{left-outer}{U.id}` という処理では、左項 (`U`) の `U.id` をもとに、右項 (`.. W ..`) の該当行を検出する処理を行っている。この検出を拡張し、同時に `limit`, `distinct` の処理を行うことで、同値類を作成する処理を1回分だけ省略することができる。

### TBD

* 平坦化と参照可視化は直交するので、個別に考えるべきか
* `U` が2回かかるような副問合せの変形 -> `U X U X V` となり個数が狂わないか？
  * そもそも、 `U` が2回かかりうる？
  * TBD: `U` を2回以上結合する場合、 `distinct{U.id}` する必要がある？
* 多くの技術解説記事で、平坦化ができないケースがある、という雰囲気を醸し出しているが、これは cross join 的なものをすると死ぬという感じ？
* 内部的な論理モデルでは、射影によって **列を除去することがない** という前提で本来は進めたい
  * 除去するのは最適化の役割で、除去せずにとっておくことで最適化自体を簡単にしたい
  * `distinct` などの set operator 系のセマンティクスが崩れるので、本文書では従来通り射影で列を除去している
